name: Build, Test and Deploy to ECS

on:
  push:
    branches:
      - main
    paths:
      - "*.py"
      - "database/**"
      - "services/**"
      - "templates/**"
      - "ai_agent/**"
      - "requirements.txt"
      - "startup.sh"
      - "Dockerfile"
      - ".dockerignore"
      - ".github/workflows/deploy.yml"
  pull_request:
    branches:
      - main
    paths:
      - "*.py"
      - "database/**"
      - "services/**"
      - "templates/**"
      - "requirements.txt"
      - "startup.sh"
      - "Dockerfile"
      - ".dockerignore"
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/k8s-flask-app
  IMAGE_TAG: aws

jobs:
  security-check:
    name: Security Gate Check
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Wait for security workflow completion
        run: |
          echo "Waiting for security workflow to complete..."
          sleep 30

      - name: Verify security checks passed
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'security.yml',
              head_sha: context.sha,
              per_page: 1
            });

            if (runs.workflow_runs.length === 0) {
              console.log('Security workflow not found for this commit');
              console.log('This is normal for the first run. Proceeding with deployment.');
              return;
            }

            const latestRun = runs.workflow_runs[0];

            if (latestRun.status === 'in_progress' || latestRun.status === 'queued') {
              console.log(`Security workflow still running: ${latestRun.status}`);
              console.log('Waiting a bit more...');
              await new Promise(resolve => setTimeout(resolve, 60000));
              
              const { data: updatedRun } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: latestRun.id
              });
              
              if (updatedRun.status !== 'completed') {
                console.log('Security workflow still not completed, but allowing deployment');
                return;
              }
              
              if (updatedRun.conclusion === 'failure') {
                core.setFailed(`Security workflow failed: ${updatedRun.conclusion}`);
                return;
              }
            }

            if (latestRun.conclusion === 'success') {
              console.log('Security checks passed');
            } else if (latestRun.conclusion === 'failure') {
              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: latestRun.id
              });
              
              const criticalJobs = ['dependency-scanning', 'secrets-scanning'];
              const failedCriticalJobs = jobs.jobs.filter(job => 
                criticalJobs.includes(job.name) && job.conclusion === 'failure'
              );
              
              if (failedCriticalJobs.length > 0) {
                core.setFailed(`Critical security checks failed: ${failedCriticalJobs.map(j => j.name).join(', ')}`);
                return;
              }
              
              console.log('Security workflow failed but only non-critical checks failed');
              console.log('Terraform security warnings are non-blocking for dev environment');
              console.log('Proceeding with deployment');
            } else {
              console.log(`Security workflow status: ${latestRun.conclusion || latestRun.status}`);
              console.log('Proceeding with deployment');
            }

  build-and-deploy:
    name: Build and Deploy
    needs: security-check
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.IMAGE_TAG }}
            type=sha,prefix=sha-

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: app-image:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Scan Docker image with Trivy
        continue-on-error: true
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "app-image:latest"
          format: "table"
          exit-code: "0"
          severity: "CRITICAL,HIGH"

      - name: Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push AI Agent Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./ai_agent
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:ai-agent
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Force ECS deployment - Frontend
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE_FRONTEND }} \
            --force-new-deployment

      - name: Force ECS deployment - Backend
        continue-on-error: true
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE_BACKEND }} \
            --force-new-deployment

      - name: Force ECS deployment - AI Agent
        continue-on-error: true
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service service-checker-ai-agent-service \
            --force-new-deployment

      - name: Wait for service stability
        run: |
          echo "Waiting for service to become stable..."
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE_FRONTEND }} \
            --region ${{ secrets.AWS_REGION }}
          echo "Deployment completed successfully!"

      - name: Configure AWS credentials for status check
        if: success()
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get deployment status
        if: success()
        run: |
          echo "Deployment Status:"
          aws ecs describe-services \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE_FRONTEND }} \
            --region ${{ secrets.AWS_REGION }} \
            --query 'services[0].deployments[0]' \
            --output json

  deploy-ai-agent:
    name: Deploy AI Agent
    needs: security-check
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Check if AI Agent files changed
        id: check_changes
        run: |
          if git diff --name-only HEAD~1 HEAD | grep -qE "(ai_agent/|templates/index.html)"; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Get Lambda Function Name
        if: steps.check_changes.outputs.changed == 'true'
        id: get_lambda
        run: |
          LAMBDA_NAME=$(aws lambda list-functions \
            --region ${{ secrets.AWS_REGION }} \
            --query "Functions[?FunctionName=='ai-agent-deploy'].FunctionName" \
            --output text)
          
          if [ -z "$LAMBDA_NAME" ]; then
            echo "Error: Lambda function ai-agent-deploy not found"
            exit 1
          fi
          
          echo "lambda_name=$LAMBDA_NAME" >> $GITHUB_OUTPUT
          echo "Found Lambda function: $LAMBDA_NAME"

      - name: Deploy AI Agent via Lambda
        if: steps.check_changes.outputs.changed == 'true'
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          YOUTUBE_API_KEY: ${{ secrets.YOUTUBE_API_KEY }}
          POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          MEILISEARCH_HOST: ${{ secrets.MEILISEARCH_HOST }}
          MEILISEARCH_PORT: ${{ secrets.MEILISEARCH_PORT }}
        run: |
          echo "Deploying AI Agent via Lambda function"
          
          if [ -z "$CURSOR_API_KEY" ]; then
            echo "Error: CURSOR_API_KEY GitHub secret is not configured"
            exit 1
          fi
          
          if [ -z "$POSTGRES_HOST" ] || [ -z "$POSTGRES_DB" ] || [ -z "$POSTGRES_USER" ] || [ -z "$POSTGRES_PASSWORD" ]; then
            echo "Error: PostgreSQL secrets are not configured"
            exit 1
          fi
          
          if [ -z "$MEILISEARCH_HOST" ]; then
            echo "Error: MEILISEARCH_HOST GitHub secret is not configured"
            exit 1
          fi
          
          PAYLOAD=$(jq -n \
            --arg cursor_key "$CURSOR_API_KEY" \
            --arg youtube_key "$YOUTUBE_API_KEY" \
            --arg pg_host "$POSTGRES_HOST" \
            --arg pg_port "${POSTGRES_PORT:-5432}" \
            --arg pg_db "$POSTGRES_DB" \
            --arg pg_user "$POSTGRES_USER" \
            --arg pg_pass "$POSTGRES_PASSWORD" \
            --arg meili_host "$MEILISEARCH_HOST" \
            --arg meili_port "${MEILISEARCH_PORT:-7700}" \
            '{
              action: "deploy",
              env_vars: {
                CURSOR_API_KEY: $cursor_key,
                CURSOR_API_BASE_URL: "https://api.cursor.com/v1",
                CURSOR_MODEL: "gpt-4o-mini",
                POSTGRES_HOST: $pg_host,
                POSTGRES_PORT: $pg_port,
                POSTGRES_DB: $pg_db,
                POSTGRES_USER: $pg_user,
                POSTGRES_PASSWORD: $pg_pass,
                MEILISEARCH_HOST: $meili_host,
                MEILISEARCH_PORT: $meili_port,
                REDIS_HOST: $meili_host,
                REDIS_PORT: "6379"
              } + (if $youtube_key != "" then {YOUTUBE_API_KEY: $youtube_key} else {} end)
            }')
          
          echo "Invoking Lambda function..."
          RESPONSE=$(aws lambda invoke \
            --function-name ${{ steps.get_lambda.outputs.lambda_name }} \
            --region ${{ secrets.AWS_REGION }} \
            --payload "$PAYLOAD" \
            --cli-binary-format raw-in-base64-out \
            /tmp/lambda-response.json)
          
          cat /tmp/lambda-response.json
          
          EXIT_CODE=$(jq -r '.statusCode' /tmp/lambda-response.json)
          RESPONSE_BODY=$(jq -r '.body' /tmp/lambda-response.json)
          
          if [ "$EXIT_CODE" != "200" ]; then
            echo "Lambda deployment failed with status code: $EXIT_CODE"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          
          SUCCESS=$(echo "$RESPONSE_BODY" | jq -r '.success')
          if [ "$SUCCESS" != "true" ]; then
            echo "Deployment failed"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          
          echo "Deployment completed successfully"
          echo "$RESPONSE_BODY" | jq '.'
